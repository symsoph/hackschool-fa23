{"version":3,"file":"index.js","sources":["../src/Actions/reset.ts","../src/Actions/index.ts","../src/types.ts","../src/index.ts","../src/Actions/setCurrentIndex.ts","../src/Actions/end.ts","../src/Actions/typingInsert.ts","../src/Actions/typingDelete.ts"],"sourcesContent":["import type { TypingStateType } from '../types';\n\nexport default (state: TypingStateType): TypingStateType => {\n  let { chars } = state;\n\n  return {\n    ...state,\n    startTime: null,\n    endTime: null,\n    charsState: new Array(chars.length).fill(0),\n    currIndex: -1,\n    currChar: '',\n    correctChar: 0,\n    errorChar: 0,\n    phase: 0,\n  };\n};\n","import type { TypingStateType } from '../types';\n\nexport enum ActionType {\n  _ONTEXTCHANGE = 'INTERNAL/ONTEXTCHANGE',\n  RESET = 'RESET',\n  END = 'END',\n  TYPINGINSERT = 'TYPING/INSERT',\n  TYPINGDELETE = 'TYPING/DELETE',\n  SETCURRENTINDEX = 'SET/CURRENTINDEX',\n}\n\nexport type ActionItemType =\n  | { type: ActionType.RESET; payload?: undefined }\n  | { type: ActionType.END; payload?: undefined }\n  | { type: ActionType.TYPINGDELETE; payload: boolean }\n  | { type: ActionType.TYPINGINSERT; payload: string | null }\n  | { type: ActionType.SETCURRENTINDEX; payload: number }\n  | {type: ActionType._ONTEXTCHANGE; payload: TypingStateType}\n\nexport { default as RESET } from './reset';\nexport { default as SETCURRENTINDEX } from './setCurrentIndex';\nexport { default as END } from './end';\nexport { default as TYPINGINSERT } from './typingInsert';\nexport { default as TYPINGDELETE } from './typingDelete';\n","type countErrorTypes = 'everytime' | 'once';\n\ntype valueof<T> = T[keyof T];\n\n/**\n * Constants for different phases.\n */\nexport const PhaseType = {\n  /**\n   * Phase when typing has yet to start.\n   */\n  NotStarted: 0,\n  /**\n   * Phase when typing has started.\n   */\n  Started: 1,\n  /**\n   * Phase when typing has ended.\n   */\n  Ended: 2,\n} as const;\n\n/**\n * Constants for different character states.\n */\nexport const CharStateType = {\n  /**\n   * Character has yet to be determined to be correct or incorrect.\n   */\n  Incomplete: 0,\n  /**\n   * Character is determined to be correct.\n   */\n  Correct: 1,\n  /**\n   * Character is determined to be incorrect.\n   */\n  Incorrect: 2,\n} as const;\n\nexport interface TypingOptionsType {\n  /**\n   * Move on to the next word when space is inputted, defaults to `true`.\n   */\n  skipCurrentWordOnSpace: boolean;\n  /**\n   * Stay on the current index when the inputted character is wrong, defaults to `false`.\n   */\n  pauseOnError: boolean;\n  /**\n   * With `everytime`, choose to count errors everytime a mistake is made.\n   * With `once`, choose to count errors only once for each mistake made.\n   */\n  countErrors: countErrorTypes;\n}\n\n/**\n * Properties of the typing game hook.\n */\nexport interface TypingStateType extends TypingOptionsType {\n  /**\n   * The inputted string to be used.\n   */\n  chars: string;\n  /**\n   * Array of each character's state in the string.\n   * Each item in the array represents the state of each character in the string.\n   * `0` represents incomplete, `1` represents correct and, `2` represents incorrect.\n   */\n  charsState: valueof<typeof CharStateType>[];\n  /**\n   * Length of the string used.\n   */\n  length: number;\n  /**\n   * Current index of the character the user have typed till.\n   */\n  currIndex: number;\n  /**\n   * Current character the user have typed till.\n   */\n  currChar: string;\n  /**\n   * Number of correct character the user had typed.\n   */\n  correctChar: number;\n  /**\n   * Number of incorrect character the user had typed.\n   */\n  errorChar: number;\n  /**\n   * Represent the current state.\n   * `0` typing haven't started, `1` typing started, `2` typing ended.\n   */\n  phase: valueof<typeof PhaseType>;\n  /**\n   * Time in milliseconds when the typing started.\n   */\n  startTime: number | null;\n  /**\n   * Time in milliseconds when the typing ended.\n   */\n  endTime: number | null;\n}\n\n/**\n * Methods of the typing game hook.\n */\nexport interface TypingActionType {\n  /**\n   * Duration in milliseconds since the typing started.\n   * 0 if the typing has yet to start.\n   * When the typing ended, the duration will be equivalent to endTime - startTime.\n   */\n  getDuration: () => number;\n  /**\n   * Reset the typing sequence.\n   */\n  resetTyping: () => void;\n  /**\n   * Ends the typing sequence but not reset it.\n   */\n  endTyping: () => void;\n  /**\n   * Insert a character into the current typing sequence.\n   * @param {string | null} char A character to be inserted.\n   * If falsy or no argument is supplied, skip the current character.\n   */\n  insertTyping: (char?: string) => void;\n  /**\n   * Delete a character from the current typing sequence.\n   * @param {boolean} [deleteWord] If `true`, deletes the whole of the current word. Defaults to `false`.\n   */\n  deleteTyping: (deleteWord?: boolean) => void;\n  /**\n   * Set the current index manually.\n   * @param {number} num Allows from -1 to length - 1 of the text, numbers that falls outside of the range will return a false.\n   */\n  setCurrIndex: (num: number) => boolean;\n}\n","import { Reducer, useCallback, useEffect, useMemo, useReducer } from 'react';\nimport {\n  RESET,\n  SETCURRENTINDEX,\n  END,\n  TYPINGINSERT,\n  TYPINGDELETE,\n  ActionType,\n  ActionItemType,\n} from './Actions';\n\nimport {\n  CharStateType,\n  PhaseType,\n  TypingActionType,\n  TypingOptionsType,\n  TypingStateType,\n} from './types';\n\nconst reducer: Reducer<TypingStateType, ActionItemType> = (state, action) => {\n  switch (action.type) {\n    case ActionType.SETCURRENTINDEX:\n      return SETCURRENTINDEX(state, action);\n    case ActionType.RESET:\n      return RESET(state);\n    case ActionType.END:\n      return END(state);\n    case ActionType.TYPINGINSERT:\n      return TYPINGINSERT(state, action);\n    case ActionType.TYPINGDELETE:\n      return TYPINGDELETE(state, action);\n    case ActionType._ONTEXTCHANGE:\n      return action.payload;\n    default: {\n      return state;\n    }\n  }\n};\n\n/**\n * React hook to create typing challenge/game/practice/test.\n * @param {string} text A string of words to be used for the typing sequence.\n * @param {Object} [options] Addition options to customize the functionality of the typing sequence.\n * @param {boolean} [options.skipCurrentWordOnSpace] Move on to the next word when space is inputted, defaults to `true`.\n * @param {boolean} [options.pauseOnError] Stay on the current index when the inputted character is wrong, defaults to `false`.\n * @param {countErrorTypes} [options.countErrors]\n * @returns Returns the state and the actions available for the typing hook.\n */\nconst useTypingGame = (\n  text: string = '',\n  options: Partial<TypingOptionsType> = {}\n): { states: TypingStateType; actions: TypingActionType } => {\n  const initialState = useMemo<TypingStateType>(\n    () => ({\n      startTime: null,\n      endTime: null,\n      chars: text,\n      charsState: new Array(text.length).fill(0),\n      length: text.length,\n      currIndex: -1,\n      currChar: '',\n      correctChar: 0,\n      errorChar: 0,\n      phase: 0,\n      skipCurrentWordOnSpace: true,\n      pauseOnError: false,\n      countErrors: 'everytime',\n      ...options,\n    }),\n    [options, text]\n  );\n\n  const [states, dispatch] = useReducer<\n    Reducer<TypingStateType, ActionItemType>\n  >(reducer, initialState);\n\n  useEffect(() => {\n    dispatch({\n      type: ActionType._ONTEXTCHANGE,\n      payload: initialState,\n    });\n  }, [text, dispatch]);\n\n  const getDuration = useCallback<TypingActionType['getDuration']>(() => {\n    switch (states.phase) {\n      case PhaseType.NotStarted: {\n        return 0;\n      }\n      case PhaseType.Started: {\n        return states.startTime ? new Date().getTime() - states.startTime : 0;\n      }\n      case PhaseType.Ended: {\n        return states.startTime && states.endTime\n          ? states.endTime - states.startTime\n          : 0;\n      }\n    }\n  }, [states.phase, states.startTime, states.startTime]);\n\n  const resetTyping = useCallback<TypingActionType['resetTyping']>(\n    () => dispatch({ type: ActionType.RESET }),\n    [dispatch]\n  );\n\n  const endTyping = useCallback<TypingActionType['endTyping']>(\n    () => dispatch({ type: ActionType.END }),\n    [dispatch]\n  );\n\n  const insertTyping = useCallback<TypingActionType['insertTyping']>(\n    (letter: string | undefined) => {\n      const payload = letter ? letter[0] : null;\n      dispatch({\n        type: ActionType.TYPINGINSERT,\n        payload,\n      });\n    },\n    [dispatch]\n  );\n\n  const deleteTyping = useCallback<TypingActionType['deleteTyping']>(\n    (deleteWord = false) => {\n      dispatch({\n        type: ActionType.TYPINGDELETE,\n        payload: deleteWord || false,\n      });\n    },\n    [dispatch]\n  );\n\n  const setCurrIndex = useCallback<TypingActionType['setCurrIndex']>(\n    (num: number) => {\n      if (num < -1 || num >= states.length || states.phase !== 2) {\n        return false;\n      }\n      dispatch({\n        type: ActionType.SETCURRENTINDEX,\n        payload: num,\n      });\n      return true;\n    },\n    [dispatch, states.length, states.phase]\n  );\n\n  return {\n    states,\n    actions: {\n      getDuration,\n      resetTyping,\n      endTyping,\n      insertTyping,\n      deleteTyping,\n      setCurrIndex,\n    },\n  };\n};\n\nexport default useTypingGame;\n\nexport {\n  CharStateType,\n  PhaseType,\n  TypingActionType,\n  TypingOptionsType,\n  TypingStateType,\n};\n","import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let { chars, length } = state;\n  let payload = action.payload ?? null;\n  if (\n    payload &&\n    typeof payload === 'number' &&\n    payload >= -1 &&\n    payload < length\n  ) {\n    return { ...state, currIndex: payload, currChar: chars[payload] };\n  } else {\n    return state;\n  }\n};\n","import type { TypingStateType } from '../types';\n\nexport default (state: TypingStateType): TypingStateType => ({\n  ...state,\n  phase: 2,\n  endTime: new Date().getTime(),\n});\n","import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    startTime,\n    endTime,\n    chars,\n    charsState,\n    length,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    skipCurrentWordOnSpace,\n    pauseOnError,\n    countErrors,\n  } = state;\n  let letter = action.payload ?? null;\n  let newStartTime = startTime;\n  let newEndTime = endTime;\n  if (phase === 2) {\n    return state;\n  }\n\n  if (phase === 0) {\n    phase = 1;\n    newStartTime = new Date().getTime();\n  }\n\n  let newCharsState = [...charsState];\n  if (\n    letter === ' ' &&\n    chars[currIndex + 1] !== ' ' &&\n    skipCurrentWordOnSpace\n  ) {\n    let newIndex = chars.indexOf(letter, currIndex);\n    currIndex = newIndex === -1 ? length - 1 : newIndex;\n  } else {\n    if (letter !== null) {\n      if (chars[currIndex + 1] !== letter) {\n        if (newCharsState[currIndex + 1] == 2) {\n          if (countErrors === 'everytime') {\n            errorChar += 1;\n          }\n        } else {\n          newCharsState[currIndex + 1] = 2;\n          errorChar += 1;\n        }\n        if (!pauseOnError) {\n          currIndex += 1;\n        }\n      } else {\n        if (\n          newCharsState[currIndex + 1] === 2 &&\n          pauseOnError &&\n          countErrors === 'once'\n        ) {\n          errorChar -= 1;\n        }\n        newCharsState[currIndex + 1] = 1;\n        correctChar += 1;\n        currIndex += 1;\n      }\n    } else {\n      currIndex += 1;\n    }\n  }\n\n  if (currIndex >= length - 1) {\n    newEndTime = new Date().getTime();\n    phase = 2;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    charsState: newCharsState,\n    errorChar,\n    correctChar,\n    currIndex,\n    currChar,\n    phase,\n    startTime: newStartTime,\n    endTime: newEndTime,\n  };\n};\n","import { ActionItemType } from './index';\nimport type { TypingStateType } from '../types';\n\nexport default (\n  state: TypingStateType,\n  action: ActionItemType\n): TypingStateType => {\n  let {\n    chars,\n    charsState,\n    currIndex,\n    correctChar,\n    errorChar,\n    phase,\n    countErrors,\n  } = state;\n  let payload = action.payload ?? null;\n\n  if (phase !== 1 || currIndex === -1) {\n    return state;\n  }\n  let newCharsState = [...charsState];\n  if (payload) {\n    let newIndex = chars.lastIndexOf(' ', currIndex);\n    newIndex = newIndex === -1 ? 0 : newIndex + 1;\n    for (let i = currIndex; i >= newIndex; i--) {\n      if (newCharsState[i] === 1) {\n        correctChar -= 1;\n      } else if (newCharsState[i] === 2) {\n        if (countErrors === 'once') {\n          errorChar -= 1;\n        }\n      }\n      newCharsState[i] = 0;\n    }\n    currIndex = newIndex;\n  } else {\n    if (newCharsState[currIndex] === 1) {\n      correctChar -= 1;\n    } else if (newCharsState[currIndex] === 2) {\n      if (countErrors === 'once') {\n        errorChar -= 1;\n      }\n    }\n    newCharsState[currIndex] = 0;\n  }\n  if (currIndex !== -1) {\n    currIndex -= 1;\n  }\n  let currChar = currIndex >= 0 ? chars[currIndex] : '';\n  return {\n    ...state,\n    currIndex,\n    currChar,\n    charsState: newCharsState,\n    correctChar,\n    errorChar,\n  };\n};\n"],"names":["ActionType","PhaseType","NotStarted","Started","Ended","reducer","state","action","type","SETCURRENTINDEX","chars","length","payload","currIndex","currChar","RESET","startTime","endTime","charsState","Array","fill","correctChar","errorChar","phase","END","Date","getTime","TYPINGINSERT","skipCurrentWordOnSpace","pauseOnError","countErrors","letter","newStartTime","newEndTime","newCharsState","newIndex","indexOf","TYPINGDELETE","lastIndexOf","i","_ONTEXTCHANGE","Incomplete","Correct","Incorrect","text","options","initialState","useMemo","_a","useReducer","states","dispatch","useEffect","getDuration","useCallback","resetTyping","endTyping","insertTyping","deleteTyping","deleteWord","setCurrIndex","num","actions"],"mappings":"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"}